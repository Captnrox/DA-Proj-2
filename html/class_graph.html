<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA-Proj-2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA-Proj-2
   </div>
   <div id="projectbrief">Travelling Salesman Problem Algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a092299cb23c1e188cebb66516c2696b8" id="r_a092299cb23c1e188cebb66516c2696b8"><td class="memItemLeft" align="right" valign="top"><a id="a092299cb23c1e188cebb66516c2696b8" name="a092299cb23c1e188cebb66516c2696b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> (int n, set&lt; vector&lt; string &gt; &gt; edges, unordered_map&lt; unsigned int, pair&lt; double, double &gt; &gt; coords={})</td></tr>
<tr class="separator:a092299cb23c1e188cebb66516c2696b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a9da7ddc2d56047835a1f55e578322" id="r_af6a9da7ddc2d56047835a1f55e578322"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af6a9da7ddc2d56047835a1f55e578322">getDist</a> (int a, int b)</td></tr>
<tr class="memdesc:af6a9da7ddc2d56047835a1f55e578322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance of two points.  <br /></td></tr>
<tr class="separator:af6a9da7ddc2d56047835a1f55e578322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f0dc038fafbdda52dccdc05aa574c5" id="r_a19f0dc038fafbdda52dccdc05aa574c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a19f0dc038fafbdda52dccdc05aa574c5">connectAllVertex</a> ()</td></tr>
<tr class="memdesc:a19f0dc038fafbdda52dccdc05aa574c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects all vertexes, by setting their distance to something other than infinite using the haversine method.  <br /></td></tr>
<tr class="separator:a19f0dc038fafbdda52dccdc05aa574c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de36bcb031663da79fc00f5aa0eaede" id="r_a1de36bcb031663da79fc00f5aa0eaede"><td class="memItemLeft" align="right" valign="top"><a id="a1de36bcb031663da79fc00f5aa0eaede" name="a1de36bcb031663da79fc00f5aa0eaede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>kruskal</b> ()</td></tr>
<tr class="memdesc:a1de36bcb031663da79fc00f5aa0eaede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the kruskal algorithm to create an mst Time Complexity: O(ElogE), where E is the number of edges in the graph. <br /></td></tr>
<tr class="separator:a1de36bcb031663da79fc00f5aa0eaede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca239012103ede21f7cc2cf2976c3a5" id="r_aeca239012103ede21f7cc2cf2976c3a5"><td class="memItemLeft" align="right" valign="top"><a id="aeca239012103ede21f7cc2cf2976c3a5" name="aeca239012103ede21f7cc2cf2976c3a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetGraph</b> ()</td></tr>
<tr class="memdesc:aeca239012103ede21f7cc2cf2976c3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the adjacency list and the visited list of nodes for the graph <br /></td></tr>
<tr class="separator:aeca239012103ede21f7cc2cf2976c3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e033a5142134ebe228a500c2c2f86a" id="r_a05e033a5142134ebe228a500c2c2f86a"><td class="memItemLeft" align="right" valign="top"><a id="a05e033a5142134ebe228a500c2c2f86a" name="a05e033a5142134ebe228a500c2c2f86a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dfs</b> (int startNode, vector&lt; int &gt; *result)</td></tr>
<tr class="memdesc:a05e033a5142134ebe228a500c2c2f86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm used to iterate over the adjacency matrix. <br /></td></tr>
<tr class="separator:a05e033a5142134ebe228a500c2c2f86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c5e024e8d820a4fd2cdb1ac7c35b0a" id="r_a37c5e024e8d820a4fd2cdb1ac7c35b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a37c5e024e8d820a4fd2cdb1ac7c35b0a">backTracking</a> ()</td></tr>
<tr class="memdesc:a37c5e024e8d820a4fd2cdb1ac7c35b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">BackTracking algorithm for finding the best cost path in a graph Makes use of an auxiliary recursive function.  <br /></td></tr>
<tr class="separator:a37c5e024e8d820a4fd2cdb1ac7c35b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcec82b45bca989b233547d11910e02e" id="r_adcec82b45bca989b233547d11910e02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adcec82b45bca989b233547d11910e02e">recBackTracking</a> (vector&lt; int &gt; &amp;bestTrip, double &amp;bestCost, int currentNode, vector&lt; int &gt; &amp;currentTrip, double &amp;currentCost, long &amp;iterations)</td></tr>
<tr class="memdesc:adcec82b45bca989b233547d11910e02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive auxiliary function for finding the best cost path.  <br /></td></tr>
<tr class="separator:adcec82b45bca989b233547d11910e02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7ff9a95801dc87c6f1efe0cb4c9dfb" id="r_afb7ff9a95801dc87c6f1efe0cb4c9dfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afb7ff9a95801dc87c6f1efe0cb4c9dfb">calculateTour</a> (vector&lt; int &gt; path)</td></tr>
<tr class="memdesc:afb7ff9a95801dc87c6f1efe0cb4c9dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total distance of a TSP path.  <br /></td></tr>
<tr class="separator:afb7ff9a95801dc87c6f1efe0cb4c9dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9530838eb0d6494bc5357a35afa0b899" id="r_a9530838eb0d6494bc5357a35afa0b899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9530838eb0d6494bc5357a35afa0b899">christofides</a> (int startIndex=0)</td></tr>
<tr class="memdesc:a9530838eb0d6494bc5357a35afa0b899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Christofides algorithm for the Travelling Salesman Problem.  <br /></td></tr>
<tr class="separator:a9530838eb0d6494bc5357a35afa0b899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be8836a5acf6b6c09d99744f56f6bbb" id="r_a4be8836a5acf6b6c09d99744f56f6bbb"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4be8836a5acf6b6c09d99744f56f6bbb">minWeightMatching</a> (vector&lt; int &gt; oddVertices)</td></tr>
<tr class="memdesc:a4be8836a5acf6b6c09d99744f56f6bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a minimum weight perfect matching of the given vertices.  <br /></td></tr>
<tr class="separator:a4be8836a5acf6b6c09d99744f56f6bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1f06d4fcf3dea0a279a46eadd91eec" id="r_a3a1f06d4fcf3dea0a279a46eadd91eec"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3a1f06d4fcf3dea0a279a46eadd91eec">eulerianCircuit</a> ()</td></tr>
<tr class="memdesc:a3a1f06d4fcf3dea0a279a46eadd91eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Eulerian circuit in the graph.  <br /></td></tr>
<tr class="separator:a3a1f06d4fcf3dea0a279a46eadd91eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e390a94e125bf4e8ec42a34241051d" id="r_ae7e390a94e125bf4e8ec42a34241051d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae7e390a94e125bf4e8ec42a34241051d">triangularAproximation</a> (bool realWorld)</td></tr>
<tr class="memdesc:ae7e390a94e125bf4e8ec42a34241051d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a TSP path that visits all the nodes of the graph exactly once.  <br /></td></tr>
<tr class="separator:ae7e390a94e125bf4e8ec42a34241051d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b6e0d4b9efc6dcd3e9ce29f5d0674" id="r_a4d7b6e0d4b9efc6dcd3e9ce29f5d0674"><td class="memItemLeft" align="right" valign="top"><a id="a4d7b6e0d4b9efc6dcd3e9ce29f5d0674" name="a4d7b6e0d4b9efc6dcd3e9ce29f5d0674"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildAdjacencyList</b> ()</td></tr>
<tr class="memdesc:a4d7b6e0d4b9efc6dcd3e9ce29f5d0674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the adjacency list of a graph based on the distances being available or not, helpful for bfs and dfs Time Complexity: O(n^2), where n is the number of vertices in the graph. <br /></td></tr>
<tr class="separator:a4d7b6e0d4b9efc6dcd3e9ce29f5d0674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8713a17392a967d2f0bd65ce47ead1" id="r_a6c8713a17392a967d2f0bd65ce47ead1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6c8713a17392a967d2f0bd65ce47ead1">bfs</a> (int startNode)</td></tr>
<tr class="memdesc:a6c8713a17392a967d2f0bd65ce47ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs over the adjacency list and visits all nodes to verify if they are all connected.  <br /></td></tr>
<tr class="separator:a6c8713a17392a967d2f0bd65ce47ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3823395f329dbcb6c43ae9836ee0afc" id="r_ab3823395f329dbcb6c43ae9836ee0afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab3823395f329dbcb6c43ae9836ee0afc">extraHeuristic</a> (int node)</td></tr>
<tr class="separator:ab3823395f329dbcb6c43ae9836ee0afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37c5e024e8d820a4fd2cdb1ac7c35b0a" name="a37c5e024e8d820a4fd2cdb1ac7c35b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c5e024e8d820a4fd2cdb1ac7c35b0a">&#9670;&#160;</a></span>backTracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::backTracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BackTracking algorithm for finding the best cost path in a graph Makes use of an auxiliary recursive function. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a6c8713a17392a967d2f0bd65ce47ead1" name="a6c8713a17392a967d2f0bd65ce47ead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8713a17392a967d2f0bd65ce47ead1">&#9670;&#160;</a></span>bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs over the adjacency list and visits all nodes to verify if they are all connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>Starting node for the bfs Time Complexity: O(n + E), where n is the number of vertices and E is the number of edges in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb7ff9a95801dc87c6f1efe0cb4c9dfb" name="afb7ff9a95801dc87c6f1efe0cb4c9dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7ff9a95801dc87c6f1efe0cb4c9dfb">&#9670;&#160;</a></span>calculateTour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculateTour </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total distance of a TSP path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>List of ordered nodes that represent the order of nodes to visit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns total distance of the path </dd></dl>

</div>
</div>
<a id="a9530838eb0d6494bc5357a35afa0b899" name="a9530838eb0d6494bc5357a35afa0b899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9530838eb0d6494bc5357a35afa0b899">&#9670;&#160;</a></span>christofides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::christofides </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the Christofides algorithm for the Travelling Salesman Problem. </p>
<p>The Christofides algorithm is an approximation algorithm for the Travelling Salesman Problem. It guarantees that the length of the tour is within 1.5 times the optimal.</p>
<p>The algorithm works as follows:</p><ol type="1">
<li>Create a minimum spanning tree of the graph.</li>
<li>Find all vertices that have odd degree in the MST.</li>
<li>Find a minimum weight perfect matching of these vertices.</li>
<li>Combine the edges of the MST and the matching to form a multigraph.</li>
<li>Form an Eulerian circuit on this graph.</li>
<li>Make the circuit into a Hamiltonian circuit by skipping any vertex visited more than once. Time Complexity: O(n^3), where n is the number of vertices in the graph. <dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a19f0dc038fafbdda52dccdc05aa574c5" name="a19f0dc038fafbdda52dccdc05aa574c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f0dc038fafbdda52dccdc05aa574c5">&#9670;&#160;</a></span>connectAllVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::connectAllVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects all vertexes, by setting their distance to something other than infinite using the haversine method. </p>
<p>Time Complexity: O(n^2), where n is the number of vertices in the graph. </p>

</div>
</div>
<a id="a3a1f06d4fcf3dea0a279a46eadd91eec" name="a3a1f06d4fcf3dea0a279a46eadd91eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1f06d4fcf3dea0a279a46eadd91eec">&#9670;&#160;</a></span>eulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::eulerianCircuit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an Eulerian circuit in the graph. </p>
<p>An Eulerian circuit is a circuit that visits every edge exactly once. The function uses a stack to keep track of the vertices. It starts from vertex 0 and while there are unvisited edges, it keeps adding vertices to the stack. When it reaches a vertex with no unvisited edges, it adds the vertex to the circuit. Time Complexity: O(n + E), where n is the number of vertices and E is the number of edges in the graph. </p><dl class="section return"><dt>Returns</dt><dd>A vector representing the Eulerian circuit. </dd></dl>

</div>
</div>
<a id="ab3823395f329dbcb6c43ae9836ee0afc" name="ab3823395f329dbcb6c43ae9836ee0afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3823395f329dbcb6c43ae9836ee0afc">&#9670;&#160;</a></span>extraHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::extraHeuristic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the heuristic used on 4.3, christofides, after checking if it is possible to connect all vertices through the bfs Time Complexity: O(n^3), where n is the number of vertices in the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6a9da7ddc2d56047835a1f55e578322" name="af6a9da7ddc2d56047835a1f55e578322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a9da7ddc2d56047835a1f55e578322">&#9670;&#160;</a></span>getDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getDist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the distance of two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First point </td></tr>
    <tr><td class="paramname">b</td><td>Second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between two points </dd></dl>

</div>
</div>
<a id="a4be8836a5acf6b6c09d99744f56f6bbb" name="a4be8836a5acf6b6c09d99744f56f6bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be8836a5acf6b6c09d99744f56f6bbb">&#9670;&#160;</a></span>minWeightMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, int &gt; &gt; Graph::minWeightMatching </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>oddVertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a minimum weight perfect matching of the given vertices. </p>
<p>A perfect matching is a matching where every vertex is connected to exactly one edge. The function iterates over all vertices and for each vertex, it finds the closest vertex that is not yet matched. Time Complexity: O(n^2), where n is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oddVertices</td><td>A vector of vertices with odd degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs representing the edges of the matching. </dd></dl>

</div>
</div>
<a id="adcec82b45bca989b233547d11910e02e" name="adcec82b45bca989b233547d11910e02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcec82b45bca989b233547d11910e02e">&#9670;&#160;</a></span>recBackTracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::recBackTracking </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestTrip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>currentTrip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>currentCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive auxiliary function for finding the best cost path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bestTrip</td><td>Best path found so far </td></tr>
    <tr><td class="paramname">bestCost</td><td>Cost of the best path found </td></tr>
    <tr><td class="paramname">currentTrip</td><td>Nodes visited for the curenth path </td></tr>
    <tr><td class="paramname">currentCost</td><td>Cost of the current path being traversed </td></tr>
    <tr><td class="paramname">currentNode</td><td>Current node whose adjacents are being visisted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e390a94e125bf4e8ec42a34241051d" name="ae7e390a94e125bf4e8ec42a34241051d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e390a94e125bf4e8ec42a34241051d">&#9670;&#160;</a></span>triangularAproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::triangularAproximation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realWorld</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a TSP path that visits all the nodes of the graph exactly once. </p>
<p>This is an algorithm is an approximation algorithm for the Travelling Salesman Problem, and works as follows;</p>
<p>1.Create an mst with the nodes of the graph 2.Run over the mst using a dfs and set a path of nodes to follow 3.Knowing the graph is fully connected and that the rule of triangular inequality guarantees that going from one node to another is always better than going back, connect all nodes in order 4.Calculate the size of the path</p>
<p>Time Complexity: O(n^2), where n is the number of vertices in the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realWorld</td><td>Boolean used to determine if some distances have to be calculated using haversine or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>src/<b>Graph.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
